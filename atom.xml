<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RedOranges</title>
  
  <subtitle>Life is Simple</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://JieZi7.github.io/"/>
  <updated>2019-04-03T15:51:41.140Z</updated>
  <id>https://JieZi7.github.io/</id>
  
  <author>
    <name>JieZI7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Win32程序运行原理</title>
    <link href="https://JieZi7.github.io/Programing2019/04/03/2_Win32_Principle.html"/>
    <id>https://JieZi7.github.io/Programing2019/04/03/2_Win32_Principle.html</id>
    <published>2019-04-03T15:42:18.000Z</published>
    <updated>2019-04-03T15:51:41.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CPU的保护模式和Windows系统"><a href="#1-CPU的保护模式和Windows系统" class="headerlink" title="1  CPU的保护模式和Windows系统"></a>1  CPU的保护模式和Windows系统</h2><h3 id="1-1-兼容性与多任务"><a href="#1-1-兼容性与多任务" class="headerlink" title="1.1 兼容性与多任务"></a>1.1 兼容性与多任务</h3><ul><li>实模式和虚拟86模式是为了兼容8086处理器</li><li>保护模式是80386处理器的主要工作模式</li></ul><p>多任务的实现：使用<strong>多任务隔离技术</strong>来使得每个任务都有自己的<strong>独立的地址空间</strong>。</p><p>在Windows下，任务被进程取代。<br><a id="more"></a></p><h3 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2  虚拟内存"></a>1.2  虚拟内存</h3><ol><li>32位的Windows系统可寻址4GB的地址空间</li><li>Windows 为每个进程分配<strong>4GB</strong>的地址空间</li><li>地址空间很大，RAM不够怎么办</li><li>使用<strong>虚拟内存</strong>技术解决</li><li>4GB的地址空间中，0x0000_0000—-&gt;0x7FFF_FFFF给进程作为私有存储，0x8000_0000—-&gt;0xFFFF_FFFF来存储操作系统的数据。<ol><li>其中私有存储，其他进程是没有办法读写这部分的数据</li><li>系统空间中的放置操作系统的代码，包括<strong>内核代码、设备驱动代码、设备I/O代码和设备I/O缓冲区等</strong>。这部分代码是共享的。</li></ol></li></ol><h3 id="1-3-内核模式和用户模式"><a href="#1-3-内核模式和用户模式" class="headerlink" title="1.3 内核模式和用户模式"></a>1.3 内核模式和用户模式</h3><p>80386定义了4（0~3）种特权级别，称之为<strong>环</strong>。但是只是使用了两层，0和3。</p><p>被称为<strong>特权级</strong>和<strong>用户级</strong>。</p><p>在内存中的每一页都有标记，标记了哪个模式下的代码有访问权限。</p><h2 id="2-内核对象"><a href="#2-内核对象" class="headerlink" title="2  内核对象"></a>2  内核对象</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1  基本概念"></a>2.1  基本概念</h3><p>内核对象是一块<strong>内存</strong>，有内核分配，只有在内核模式被访问（只有通过API函数来访问）。</p><p>内核对象记录的数据在系统中只有一份。</p><p>就是你创建了一个窗口，那么这个窗口的信息就存储在内核对象中。只有通过API函数才能访问这些数据。</p><h3 id="2-2-对象句柄"><a href="#2-2-对象句柄" class="headerlink" title="2.2  对象句柄"></a>2.2  对象句柄</h3><p>用过调用API函数访问内核对象的时候，就需要知道访问的是哪一个内核对象，就通过对象的句柄来解决， 相当于对象的<strong>标志符</strong>。</p><h3 id="2-3-使用计数"><a href="#2-3-使用计数" class="headerlink" title="2.3  使用计数"></a>2.3  使用计数</h3><p>每有一个内核对象的引用，，就会把对象的计数属性+1，当系统发现该对象的引用数为0的时候，系统会释放掉这个资源。</p><h2 id="3-进程的创建"><a href="#3-进程的创建" class="headerlink" title="3  进程的创建"></a>3  进程的创建</h2><h3 id="3-1-进程（Process）和线程（Thread）"><a href="#3-1-进程（Process）和线程（Thread）" class="headerlink" title="3.1  进程（Process）和线程（Thread）"></a>3.1  进程（Process）和线程（Thread）</h3><p>进程通常被定义为==正在运行的程序的实例==。</p><blockquote><p>进程是一个正在运行的程序，它拥有自己的虚拟地址空间，拥有自己的代码，数据和其他系统资源，如进程创建的文件、管道、同步对象等。一个进程也包含了一个或者多个运行在此进程内的线程。</p></blockquote><ul><li>程序是静态的指令</li><li>进程是一个容器</li><li>线程执行代码</li></ul><p>线程是进行内<strong>执行代码的独立实体</strong>。没有线程，程序无法执行。</p><p>操作系统创建了进程之后，会创建一个线程执行进程中的代码。</p><p>这个线程被称为主线程，主线程在运行过程中可能会创建其他线程。这种线程被称为<strong>辅助线程</strong>。</p><h3 id="3-2-应用程序的启动过程"><a href="#3-2-应用程序的启动过程" class="headerlink" title="3.2  应用程序的启动过程"></a>3.2  应用程序的启动过程</h3><p>应用程序必须有一个入口函数，在<strong>程序运行的时候</strong>被调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>但是，实际上，操作系统<strong>并不是</strong>真的调用main函数，而是去调用的是c/c++的运行期库，目的是初始化所有的对象。</p><p>运行期启动的函数会调用程序入口函数main。</p><p>总的来说是这样的：</p><ol><li>操作系统调用CreateProcess函数来创建新的进程。</li><li>系统为这一个新的进程创建一个主线程，这个主线程通过执行C/C++运行期启动的代码开始运行。</li></ol><p>系统创建新的进程的时候会给新的进程指定一个==STARTUPINFO==类型的变量。</p><p>这个变量的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    DWORD   cb; <span class="comment">//本结构的长度，固定值 sizeof（STARTUPINFO)</span></span><br><span class="line">    LPSTR   lpReserved；<span class="comment">//保留字段，不使用</span></span><br><span class="line">    LPSTR   lpDesktop;<span class="comment">//指定桌面名称</span></span><br><span class="line">    LPSTR   lpTitle; <span class="comment">//指定控制台窗口标题</span></span><br><span class="line">    DWORD   dwX;  <span class="comment">//指定新建窗口的位置坐标和大小</span></span><br><span class="line">    DWORD   dwY;</span><br><span class="line">    DWORD   dwXSize;</span><br><span class="line">    DWORD   dwYSize;</span><br><span class="line">    DWORD   dwXCountChars; <span class="comment">//控制台程序使用，指令控制台窗口的行数</span></span><br><span class="line">    DWORD   dwYCountChars;</span><br><span class="line">    DWORD   dwFillAttribute;<span class="comment">//控制台应用使用，指定控制台窗口的背景颜色</span></span><br><span class="line">    DWORD   dwFlags; <span class="comment">//标志，它的值决定了结构中那些值是有效的</span></span><br><span class="line">    WORD    wShowWindow; <span class="comment">// 窗口的显示方式</span></span><br><span class="line">    WORD    cbReserved2;</span><br><span class="line">    LPBYTE  lpReserved2;</span><br><span class="line">    HANDLE  hStdInput; <span class="comment">//控制台程序使用，几个标准句柄</span></span><br><span class="line">    HANDLE  hStdOutput;</span><br><span class="line">    HANDLE  hStdError;</span><br><span class="line">&#125;STARTUPINFO, *LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><p>也就是说，使用CreateProcess()函数之前，需要初始化 STARTUPINFO 结构</p><p>还有就是可以通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">GetStartupInfo</span><span class="params">(LPSTARTUPINFO lpStartInfo)</span></span>;<span class="comment">//取得当前进程被创建时指定的STARTUPINFO结构</span></span><br><span class="line"><span class="comment">//初始化STARTUPINFO</span></span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">::GetStartupInfo(&amp;si);</span><br></pre></td></tr></table></figure><h3 id="3-3-CreateProcess函数"><a href="#3-3-CreateProcess函数" class="headerlink" title="3.3  CreateProcess函数"></a>3.3  CreateProcess函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BOOL CreateProcess</span><br><span class="line">(</span><br><span class="line">    LPCTSTR lpApplicationName,      <span class="comment">//可执行文件名称  </span></span><br><span class="line">    LPTSTR lpCommandLine,        <span class="comment">//传递给执行文件的参数</span></span><br><span class="line">    LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//进程安全性</span></span><br><span class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">//线程安全性</span></span><br><span class="line">    BOOL bInheritHandles,        <span class="comment">//当前进程中的可继承句柄是否可以被新进程继承</span></span><br><span class="line">    DWORD dwCreationFlags,     <span class="comment">//制定了新进程的优先级以及其他创建标志</span></span><br><span class="line">    LPVOID lpEnvironment,       <span class="comment">//指定新进程使用的环境变量</span></span><br><span class="line">    LPCTSTR lpCurrentDirectory,        <span class="comment">//新进程使用的目录</span></span><br><span class="line">    LPSTARTUPINFO lpStartupInfo,       <span class="comment">//STARTUPINFO结构体</span></span><br><span class="line">    LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//返回新建进程的标志信息，如ID号、句柄等</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lpProcessInformation结构</span></span><br><span class="line"><span class="comment">/* 包括了进程和主线程的句柄和ID</span></span><br><span class="line"><span class="comment"> * ID号和句柄都是操作系统分配的</span></span><br><span class="line"><span class="comment"> * 每一次都可能不一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><h3 id="3-4-例子"><a href="#3-4-例子" class="headerlink" title="3.4  例子"></a>3.4  例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szCommandLine[] = <span class="string">"cmd"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义了那些值有用</span></span><br><span class="line">    <span class="comment">//要是 wShowWindow有效，必须设置为STARTF_USERHOWWINDOW</span></span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">si.wShowWindow = TRUE;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">*  创建了一个不需要名字，进程和主线程使用默认安全属性</span></span><br><span class="line"><span class="comment">*  可继承句柄不能被继承</span></span><br><span class="line"><span class="comment">*  目录和环境变量都使用调用进程的属性的</span></span><br><span class="line"><span class="comment">*  进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BOOL bRet = ::CreateProcess(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">szCommandLine,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,</span><br><span class="line">CREATE_NEW_CONSOLE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;si,</span><br><span class="line">&amp;pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line">::CloseHandle(pi.hThread);</span><br><span class="line">::CloseHandle(pi.hProcess);</span><br><span class="line"><span class="comment">//虽然关闭了进程和线程，但是信息存储在了pi中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"进程ID:%d\n"</span>, pi.dwProcessId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"线程ID:%d\n"</span>, pi.dwThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4  进程控制"></a>4  进程控制</h2><h3 id="4-1-获取系统进程"><a href="#4-1-获取系统进程" class="headerlink" title="4.1  获取系统进程"></a>4.1  获取系统进程</h3><p>使用ToolHelp函数完成 列出当前正在运行的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  typedef struct tagPROCESSENTRY32</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    DWORD   dwSize;</span></span><br><span class="line"><span class="comment">    DWORD   cntUsage;//进程的引用次数</span></span><br><span class="line"><span class="comment">    DWORD   th32ProcessID;          // this process</span></span><br><span class="line"><span class="comment">    ULONG_PTR th32DefaultHeapID;    //进程默认堆的ID</span></span><br><span class="line"><span class="comment">    DWORD   th32ModuleID;           // associated exe</span></span><br><span class="line"><span class="comment">    DWORD   cntThreads;// 进程创建的线程数</span></span><br><span class="line"><span class="comment">    DWORD   th32ParentProcessID;    // 进程的父线程ID</span></span><br><span class="line"><span class="comment">    LONG    pcPriClassBase;         // 进程创建的线程优先级</span></span><br><span class="line"><span class="comment">    DWORD   dwFlags;</span></span><br><span class="line"><span class="comment">    CHAR    szExeFile[MAX_PATH];    // 进程对应的可执行文件名</span></span><br><span class="line"><span class="comment">&#125; PROCESSENTRY32;*/</span></span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//给系统内的所有进程拍一个快照</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 第一个参数是dwFlags，指定“快照“返回的对象</span></span><br><span class="line"><span class="comment">    * 第二个参数是th32ProcessID  一个进程ID号，用来指定要获取哪一个进程的快照</span></span><br><span class="line"><span class="comment">    *当获取系统进程列表或者获取当前快照的时候设置为0</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 总结一下，这个函数可以获取指定进程的快照和系统进程列表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">TH32CS_SNAPHEAPLIST  枚举指定进程中的堆</span></span><br><span class="line"><span class="comment">TH32CS_SNAPMODULE32  枚举指定进程中的模块</span></span><br><span class="line"><span class="comment">TH32CS_SNAPPROCESS   枚举系统范围内的进程，后一个参数被忽略</span></span><br><span class="line"><span class="comment">TH32CS_SNAPTHREAD    枚举系统返回内的线程，后一个参数被忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"函数调用失败\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历快照</span></span><br><span class="line">BOOL bMore = ::Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span> (bMore)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"进程名称：%s \n"</span>, pe32.szExeFile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"进程ID号：%d \n\n"</span>, pe32.th32ProcessID);</span><br><span class="line"></span><br><span class="line">bMore = ::Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::CloseHandle(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用EnumProcess也可以完成同样的效果</span></span><br><span class="line"><span class="comment">//使用PROCESSENTRY32来存储进程的信息</span></span><br></pre></td></tr></table></figure><h3 id="4-2-终止进程"><a href="#4-2-终止进程" class="headerlink" title="4.2 终止进程"></a>4.2 终止进程</h3><p>进程终止的可能性有：</p><ul><li><p>主线程的入口返回</p></li><li><p>调用的ExitProcess函数：void ExitProcess(UNIT uExitCode)，调用这个函数对于<strong>操作系统</strong>来说是正常的，但是对于用户来说，这个函数会直接结束进程，使得c/c++运行期库不能调用全局或静态的C++对象的析构函数</p></li><li><p>此进程的所有线程都已经结束</p></li><li><p>有其他进程调用了TerminalProcess函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TerminalProcess</span><span class="params">(HANDLE hProcess, UNIT uExitCode)</span></span>;</span><br><span class="line"><span class="comment">//对于已经存在的进程的句柄的得到，就使用</span></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwDesiredAccess，<span class="comment">//想要得到的访问权限，可以是 PROCESS_ALL_ACCESS</span></span></span></span><br><span class="line"><span class="function"><span class="params">BOOL bInheritHandle,<span class="comment">// 指定返回的句柄是否可以继承</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwProcessId<span class="comment">// 指定要打开的进程ID号</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"><span class="comment">//执行失败后返回 NULL</span></span></span><br></pre></td></tr></table></figure><h3 id="保护进程"><a href="#保护进程" class="headerlink" title="保护进程"></a>保护进程</h3><p>保护进程不被其他的进程非法关闭。</p><p>一般使用ToolHelp函数或者是Process Status函数来检测系统进程，只要HOOK掉系统对这些函数的调用。</p><p>或者直接HOOK掉其他函数对TerminalProcess函数的引用。</p><h2 id="5-实例-修改内存数据"><a href="#5-实例-修改内存数据" class="headerlink" title="5  实例 修改内存数据"></a>5  实例 修改内存数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程空间进行第一次查找</span></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span>;<span class="comment">// 在目标进程地址空间进行第2、3、4……次查找</span></span><br><span class="line">DWORD g_arList[<span class="number">1024</span>];<span class="comment">// 地址列表</span></span><br><span class="line"><span class="keyword">int</span> g_nListCnt;<span class="comment">// 有效地址的个数</span></span><br><span class="line">HANDLE g_hProcess;<span class="comment">// 目标进程句柄</span></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 启动02testor进程</span></span><br><span class="line"><span class="keyword">char</span> szFileName[] = <span class="string">"..\\02testor\\debug\\02testor.exe"</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">::CreateProcess(<span class="literal">NULL</span>, szFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="comment">// 关闭线程句柄，既然我们不使用它</span></span><br><span class="line">::CloseHandle(pi.hThread);</span><br><span class="line">g_hProcess = pi.hProcess;</span><br><span class="line"><span class="comment">// 输入要修改的值</span></span><br><span class="line"><span class="keyword">int</span>iVal;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"><span class="comment">// 进行第一次查找</span></span><br><span class="line">FindFirst(iVal);</span><br><span class="line"><span class="comment">// 打印出搜索的结果</span></span><br><span class="line">ShowList();</span><br><span class="line"><span class="keyword">while</span>(g_nListCnt &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Input val = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行下次搜索</span></span><br><span class="line">FindNext(iVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示搜索结果</span></span><br><span class="line">ShowList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得新值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" New value = "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iVal);     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入新值</span></span><br><span class="line"><span class="keyword">if</span>(WriteMemory(g_arList[<span class="number">0</span>], iVal))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Write data success \n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::CloseHandle(g_hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CompareAPage</span><span class="params">(DWORD dwBaseAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 读取1页内存</span></span><br><span class="line">BYTE arBytes[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">if</span>(!::ReadProcessMemory(g_hProcess, (LPVOID)dwBaseAddr, arBytes, <span class="number">4096</span>, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> FALSE;<span class="comment">// 此页不可读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这1页内存中查找</span></span><br><span class="line">DWORD* pdw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)<span class="number">4</span>*<span class="number">1024</span><span class="number">-3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pdw = (DWORD*)&amp;arBytes[i];</span><br><span class="line"><span class="keyword">if</span>(pdw[<span class="number">0</span>] == dwValue)<span class="comment">// 等于要查找的值？</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(g_nListCnt &gt;= <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">// 添加到全局变量中</span></span><br><span class="line">g_arList[g_nListCnt++] = dwBaseAddr + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindFirst</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> DWORD dwOneGB = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// 1GB</span></span><br><span class="line"><span class="keyword">const</span> DWORD dwOnePage = <span class="number">4</span>*<span class="number">1024</span>;<span class="comment">// 4KB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_hProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作系统类型，以决定开始地址</span></span><br><span class="line">DWORD dwBase;</span><br><span class="line">OSVERSIONINFO vi = &#123; <span class="keyword">sizeof</span>(vi) &#125;;</span><br><span class="line">::GetVersionEx(&amp;vi);</span><br><span class="line"><span class="keyword">if</span> (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)</span><br><span class="line">dwBase = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// Windows 98系列，4MB</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dwBase = <span class="number">640</span>*<span class="number">1024</span>;<span class="comment">// Windows NT系列，64KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在开始地址到2GB的地址空间进行查找</span></span><br><span class="line"><span class="keyword">for</span>(; dwBase &lt; <span class="number">2</span>*dwOneGB; dwBase += dwOnePage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 比较1页大小的内存</span></span><br><span class="line">CompareAPage(dwBase, dwValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">FindNext</span><span class="params">(DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 保存m_arList数组中有效地址的个数，初始化新的m_nListCnt值</span></span><br><span class="line"><span class="keyword">int</span> nOrgCnt = g_nListCnt;</span><br><span class="line">g_nListCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_arList数组记录的地址处查找</span></span><br><span class="line">BOOL bRet = FALSE;<span class="comment">// 假设失败</span></span><br><span class="line">DWORD dwReadValue;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nOrgCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(::ReadProcessMemory(g_hProcess, (LPVOID)g_arList[i], &amp;dwReadValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dwReadValue == dwValue)</span><br><span class="line">&#123;</span><br><span class="line">g_arList[g_nListCnt++] = g_arList[i];</span><br><span class="line">bRet = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出搜索到的地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; g_nListCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%08lX \n"</span>, g_arList[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">WriteMemory</span><span class="params">(DWORD dwAddr, DWORD dwValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::WriteProcessMemory(g_hProcess, (LPVOID)dwAddr, &amp;dwValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-CPU的保护模式和Windows系统&quot;&gt;&lt;a href=&quot;#1-CPU的保护模式和Windows系统&quot; class=&quot;headerlink&quot; title=&quot;1  CPU的保护模式和Windows系统&quot;&gt;&lt;/a&gt;1  CPU的保护模式和Windows系统&lt;/h2&gt;&lt;h3 id=&quot;1-1-兼容性与多任务&quot;&gt;&lt;a href=&quot;#1-1-兼容性与多任务&quot; class=&quot;headerlink&quot; title=&quot;1.1 兼容性与多任务&quot;&gt;&lt;/a&gt;1.1 兼容性与多任务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实模式和虚拟86模式是为了兼容8086处理器&lt;/li&gt;
&lt;li&gt;保护模式是80386处理器的主要工作模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多任务的实现：使用&lt;strong&gt;多任务隔离技术&lt;/strong&gt;来使得每个任务都有自己的&lt;strong&gt;独立的地址空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Windows下，任务被进程取代。&lt;br&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://JieZi7.github.io/categories/Programing/"/>
    
    
      <category term="Win32 API函数" scheme="https://JieZi7.github.io/tags/Win32-API%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 线程</title>
    <link href="https://JieZi7.github.io/Know-More2019/03/31/OS-THREAD.html"/>
    <id>https://JieZi7.github.io/Know-More2019/03/31/OS-THREAD.html</id>
    <published>2019-03-31T15:34:49.000Z</published>
    <updated>2019-03-31T15:55:12.578Z</updated>
    
    <content type="html"><![CDATA[<h4 id="操作系统-线程"><a href="#操作系统-线程" class="headerlink" title="操作系统 线程"></a>操作系统 线程</h4><p>线程—-一种CPU利用的基本单元，它是形成多线程计算机的基础。</p><p>讨论Pthread API、Win32 API和JAVA线程库。</p><p>线程由线程ID、程序计数器(PC)、寄存器集合和栈组成。</p><p>多线程进程中的线程共享 <strong>代码、数据、文件</strong>。<br><a id="more"></a></p><p>多个线程可以<strong>同时</strong>处理不同的任务，也可以处理相同的任务。</p><p>优点：</p><ol><li>响应度高；对于用户的响应度，用户不会被进程的其他操作所耽误。</li><li>资源共享；</li><li>经济；减少了进程的创建。</li><li>多处理器体系结构的利用。增加的并发的功能。</li></ol><p>模型：</p><ol><li>多对一模型；</li><li>一对一模型；开销大。</li><li>多对多模型。</li><li>二级模型。</li></ol><h5 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h5><ul><li>在用户空间中提供一个没有内核支持的库，此库的所有代码和数据都存在与用户空间中。</li><li>执行一个由操作系统直接支持的内核级的库，此时库的代码和数据结构存在与内核空间中。调用库中的一个API函数通常会导致对内核的系统调用。</li></ul><p>主要的线程库</p><ol><li><p>POSIX Pthread，用户级和内核级。</p><p>线程行为的规范。任意实现。</p></li><li><p>Win32，内核库</p></li><li><p>Java，使用宿主系统上的线程库来实现。</p></li></ol><h5 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h5><ol><li>系统调用fork()和exec()</li></ol><p>如果调用fork之后立即调用exec，那么没有必要复制所有的线程。因为整个进程都会被替代。</p><ol><li><p>线程取消(thread cancellation)：在线程完成之前终止线程的任务。</p><ol><li>异步取消(asynachronous cancellation)：立即终止。</li><li>延迟取消(deferred cancellation)：目标线程检查它是否应该终止，目标线程以有序方式终止自己。</li></ol><p>取消点(cancellation point)</p><p>操作系统回收取消线程的系统资源，但是通常并不回收所有资源——&gt;异步取消线程并不会是所需要的系统线程空闲。</p></li><li><p>信号处理</p><ol><li>信号是由特定的事件的发生所产生的。</li><li>产生的信号要发送到进程。</li><li><p>一旦发送，信号必须加以处理。</p><p>同步信号：发送到产生信号的==同一进程==；</p><p>异步信号：信号由==运行进程之外==的事件产生。Ctrl+C</p><p>对于一个多线程程序：</p></li><li><p>发送到所应用的线程；</p></li><li>发送到进程内的每一个线程；</li><li>发送到进程内的固定线程；</li><li>规定一个特定线程接收所有信号。</li></ol><p>Windows中异步过程调用(asynchronous procedure call，APC)模拟上述UNIX操作。</p><p>但是APC只发送给特定线程。</p></li><li><p>线程池(thread pool)</p><p>总体思想是创建==一定数量==的线程，放在池中等待工作。</p><p>线程用以唤醒。</p><p>优点：</p><ol><li>快。</li><li>限制了可用线程的数量。</li></ol><p>数量由硬件和并发请求的期望来决定。高级一点的可以动态调整线程数量。</p></li><li><p>线程特定数据(thread-specific data)</p><p>每个线程都有自己的数据，不共享出去。</p></li><li><p>调度程序激活：内核和线程库之间的通信问题</p><p>用户线程 –&gt; 轻量级进程(LWP) –&gt; 内核线程</p><p>调度器激活(scheduler actication)：<br>​    内核提供一组==虚拟处理器==(LWP)给应用程序。</p><p>​    线程在虚拟处理器上运行。</p><p>​    upcall：内核告知与应用程序有关的事件。</p><p>​    upcall由具有==upcall处理句柄==的线程库处理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;操作系统-线程&quot;&gt;&lt;a href=&quot;#操作系统-线程&quot; class=&quot;headerlink&quot; title=&quot;操作系统 线程&quot;&gt;&lt;/a&gt;操作系统 线程&lt;/h4&gt;&lt;p&gt;线程—-一种CPU利用的基本单元，它是形成多线程计算机的基础。&lt;/p&gt;
&lt;p&gt;讨论Pthread API、Win32 API和JAVA线程库。&lt;/p&gt;
&lt;p&gt;线程由线程ID、程序计数器(PC)、寄存器集合和栈组成。&lt;/p&gt;
&lt;p&gt;多线程进程中的线程共享 &lt;strong&gt;代码、数据、文件&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="知道的多一点" scheme="https://JieZi7.github.io/categories/Know-More/"/>
    
    
      <category term="操作系统 线程" scheme="https://JieZi7.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
